# concurrent-noending

## 12 你以为结束了???
[返回主目录](../README.md)

### [20 通俗理解乐观锁和悲观锁](https://mp.weixin.qq.com/s?__biz=MzI3NjU2ODA5Mg==&mid=2247484165&idx=1&sn=06ac4db23d325697afd8b9fd6a7a4733&chksm=eb72c276dc054b609b1da7b1f18a99e747ccd3249ed184c56bd6c7cf785c7f7c0115b0cbb428&mpshare=1&scene=1&srcid=1002oqxBR5ZW20iWaYCK8T1d#rd)

### 20.1 乐观锁
每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。一般使用version方式和CAS操作方式。
    
#### 20.1.1 Version方式：
        一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
    
    核心SQL代码：update table set x=x+1, version=version+1 where id=#{id} and version=#{version};
    
#### 20.1.2 CAS操作方式：
        即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。
    
#### [20.1.3 详解CAS，点击查看](https://mp.weixin.qq.com/s?__biz=MzI3NjU2ODA5Mg==&mid=2247483962&idx=1&sn=65e4e306b53ceb956fd7bff82a872204&scene=21#wechat_redirect)
    
#### 20.1.4 乐观锁使用场景:
        比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。
    
### 20.2 悲观锁
每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。在Java中，synchronized的思想也是悲观锁。
    
#### 20.2.1 悲观锁使用场景:
    比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。